<!DOCTYPE html>
<html>
    <head>
        <title>PLED</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
<body style="background-color:black; color:white;" link="#58D3F7" alink="#FF00FF" vlink="#58D3F7">

<h1><a href=https://alex-free.github.io>alex-free.github.io</a></h1>

<h1>PortableLinuxExecutableDirectory (a.k.a. PLED)</h1>

<p>By Alex Free</a>

<p>PLED brings 'Windows-like software portability' to Linux. On Windows it is common for software to be distributed in this way:</p>

<ul>
    <li>The executable file (<code>.exe</code>) of the actual program is in a directory.</li>
    <li>All dynamic library files (<code>.dll</code>'s) needed to run the executable file are also found in the same directory as the executable.</li>
    <li>The Windows linker searches the directory that the executable file is in for the dynamic libraries it needs to run, finds them in the directory, and the executable loads with them.</li>
</ul>

<p>This behavior is very desirable an OS such as Linux. Packaging software for Linux can become a nightmare quickly if dynamic libraries are involved (which they almost always are unless your executable is truely statically linked). PLED is designed to make releasing Linux software easy and accessable by bringing the same Windows behavior/ideals to Linux. The PLED version of a Linux executable should run on any Linux distribution with the same architecture because it is a directory containing all linked shared libraries, the LD loader itself used by the OS to load the dynamic libraries, and a wrapper which executes the real original Linux executable using the included LD loader and self-contained shared libraries all in the same directory.</p>

<a href=https://alex-free.github.io/pled>Homepage</a> | <a href=https://github.com/alex-free/pled>GitHub</a>
<h2>Table Of Contents</h2>
<ul><li><a href="#downloads">Downloads</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#license">License</a></li></ul>

<img src="pled.png" alt="pled ffplay" width="400">

<a name="downloads"><h2>Downloads</h2></a>

<h3>v1.0.1 (9/27/2022)</h3>

<p><a href=https://github.com/alex-free/pled/releases/download/v1.0.1/pled-1.0.1.zip>PLED v1.0.1</a></p>

<p>Changes:</p>

<ul>
    <li>Calls LD loader by explicit filepath instead of first changing to the current directory of the PLED executable and then using a relative path. This improves software compatibility and fixes 'file not found' type issues PLED v1.0 had when giving a relative path as an argument to a PLED wrapper.</li>
</ul>

<h3>v1.0 (1/25/2022)</h3>

<p><a href=https://github.com/alex-free/pled/releases/download/v1.0/pled-1.0.zip>PLED v1.0</a></p>

<a name="usage"><h2>Usage</h2></a>

<p>PLED accepts only one argument. This can be an absolute file path to an executable, or simply the name of the executable <b>if it is in your <code>$PATH</code></b>. Examples:</p>

<pre><code>./pled git</code></pre><pre><code>./pled /usr/bin/git</code></pre>

<p>Both examples above achive the same thing, a <code>git-pled</code> directory created in the same directory that you executed PLED inside of. You can copy this directory to any file path location on your system, or even on an different Linux installation or distribution entirely and the <code>git</code> inside the <code>git-pled</code> directory will work as it is now portable, not depending on any external dependencies from the system to be installed. The <code>git-pled</code> directory contains 3 things:</p>

<ul><li>The <code>git</code> executable itself, however it is renamed to <code>git2</code> in the <code>git-pled</code> directory.</li>
<li>The <code>git</code> wrapper generated by PLED which executes <code>git2</code> with the ld loader and shared libraries in the <code>git-pled</code> directory.</li>
<li>The <code>git-ldd</code> script, which correctly displays the shared library linkage of the <code>git</code> PLED wrapper.</li>
</ul>

<p>It is important to note that PLED <b>requires an actual executable file as the first argument and NOT a shell-script wrapper</b>. Some software installed by your package manager may actually be a shell script wrapper, but be presented as the executable. PLED will refuse to function on such a shell script wrapper, as it verifies if the first argument is an actual executable file. If PLED finds this not to be the case, it will helpfully offer to display the shell script wrapper's contents to help you figure out where the real executable is. This is a good start, but typically it may be easier to just recompile the target software entirely yourself, figure out the configuration and any required external files, and then go from there. Another important thing to keep in mind is that PLED doesn't know about any external configuration or data files the executable may need to run. Also, some executables may load dynamic libraries at run time <b>without explicitly linking them</b>, like how <a href=https://bugs.launchpad.net/ubuntu/+source/firefox/+bug/1017964>Firefox</a> does by reading the external file dependentlibs.list.</p>

<p>One way you can debug a program in regards to required external files is by using <a href=https://strace.io/>Strace</a> (the Linux syscall tracer). In the <code>*-pled</code> directory you can compare the output of <code>strace ./yourbinary</code> and <code>strace ./yourbinary2</code> (the actual executable the wrapper executes).</p>

<a name="license"><h2>License</h2></a>

<p>PLED is released into the public domain, see the file <code>unlicense.txt</code> for more info.</p>

</html>